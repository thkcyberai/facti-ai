"""
Rate Limiting Middleware for KYCShield API
Protects against abuse and DDoS attacks
"""

from fastapi import Request, status
from fastapi.responses import JSONResponse
from datetime import datetime, timedelta
from collections import defaultdict
from typing import Dict

class RateLimiter:
    """Simple in-memory rate limiter"""
    
    def __init__(self, requests_per_minute: int = 60, requests_per_hour: int = 1000):
        self.requests_per_minute = requests_per_minute
        self.requests_per_hour = requests_per_hour
        self.minute_requests: Dict[str, list] = defaultdict(list)
        self.hour_requests: Dict[str, list] = defaultdict(list)
    
    def _get_client_ip(self, request: Request) -> str:
        """Extract client IP from request"""
        forwarded = request.headers.get("X-Forwarded-For")
        if forwarded:
            return forwarded.split(",")[0].strip()
        if request.client:
            return request.client.host
        return "unknown"
    
    def check_rate_limit(self, request: Request) -> tuple[bool, str]:
        """Check if request exceeds rate limits"""
        ip = self._get_client_ip(request)
        now = datetime.now()
        
        # Clean old entries (older than 1 minute)
        one_minute_ago = now - timedelta(minutes=1)
        self.minute_requests[ip] = [
            ts for ts in self.minute_requests[ip] 
            if ts > one_minute_ago
        ]
        
        # Count BEFORE adding new request
        current_count = len(self.minute_requests[ip])
        
        # DEBUG
        print(f"[RATE LIMITER] IP: {ip}, Count: {current_count}/{self.requests_per_minute}")
        
        # Check if we're AT the limit (not over)
        if current_count >= self.requests_per_minute:
            print(f"[RATE LIMITER] ðŸš« BLOCKING REQUEST - Limit reached!")
            return False, f"Rate limit exceeded: {current_count}/{self.requests_per_minute} requests per minute"
        
        # Add current request AFTER checking
        self.minute_requests[ip].append(now)
        
        return True, ""

# Global instance
rate_limiter = RateLimiter(requests_per_minute=60)

async def rate_limit_middleware(request: Request, call_next):
    """Middleware to enforce rate limits on all requests"""
    
    # Skip health check
    if request.url.path == "/health":
        return await call_next(request)
    
    # Check rate limit
    is_allowed, error_msg = rate_limiter.check_rate_limit(request)
    
    if not is_allowed:
        return JSONResponse(
            status_code=status.HTTP_429_TOO_MANY_REQUESTS,
            content={"error": "Rate limit exceeded", "message": error_msg},
            headers={"Retry-After": "60"}
        )
    
    return await call_next(request)
