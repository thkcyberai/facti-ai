"""
Rate Limiting Middleware for KYCShield API
Protects against abuse and DDoS attacks
"""

from fastapi import Request, status
from fastapi.responses import JSONResponse
from datetime import datetime, timedelta
from collections import defaultdict
from typing import Dict

class RateLimiter:
    """Simple in-memory rate limiter"""
    
    def __init__(self, requests_per_minute: int = 60):
        self.requests_per_minute = requests_per_minute
        self.requests: Dict[str, list] = defaultdict(list)
    
    def _get_client_ip(self, request: Request) -> str:
        """Extract client IP from request"""
        forwarded = request.headers.get("X-Forwarded-For")
        if forwarded:
            return forwarded.split(",")[0].strip()
        if request.client:
            return request.client.host
        return "unknown"
    
    def check_rate_limit(self, request: Request) -> tuple[bool, str]:
        """Check if request exceeds rate limits"""
        ip = self._get_client_ip(request)
        now = datetime.now()
        
        # Add current timestamp
        self.requests[ip].append(now)
        
        # Count requests in last 60 seconds
        one_minute_ago = now - timedelta(seconds=60)
        recent_requests = [ts for ts in self.requests[ip] if ts > one_minute_ago]
        count = len(recent_requests)
        
        # Clean up old entries (keep only last 100 for memory efficiency)
        if len(self.requests[ip]) > 100:
            self.requests[ip] = self.requests[ip][-100:]
        
        # DEBUG
        print(f"[RATE LIMITER] IP: {ip}, Count: {count}/{self.requests_per_minute}")
        
        # Check if exceeded
        if count > self.requests_per_minute:
            print(f"[RATE LIMITER] ðŸš« BLOCKING REQUEST #{count}!")
            return False, f"Rate limit exceeded: {count}/{self.requests_per_minute} requests per minute"
        
        return True, ""

# Global instance
rate_limiter = RateLimiter(requests_per_minute=60)

async def rate_limit_middleware(request: Request, call_next):
    """Middleware to enforce rate limits on all requests"""
    
    # Skip health check
    if request.url.path == "/health":
        return await call_next(request)
    
    # Check rate limit
    is_allowed, error_msg = rate_limiter.check_rate_limit(request)
    
    if not is_allowed:
        return JSONResponse(
            status_code=status.HTTP_429_TOO_MANY_REQUESTS,
            content={"error": "Rate limit exceeded", "message": error_msg},
            headers={"Retry-After": "60"}
        )
    
    return await call_next(request)
